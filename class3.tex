\section{Generative Art -- Complexity and Emergent Phenomena}
\emph{Emergence}, in the sense of generative art, is the diametric opposite of randomness.  Where randomness is chaos -- the lack of order, and presence of the unexpected -- emergence is a strict adherence to order.  Emergence is the the phenomena where a simple set of local rules create a global order.  An example is a school of fish -- each individual fish has a small number of rules that it follows based off of its immediate neighbors.  But when taken as a whole, the behavior of a school of fish is quite complex.

This section of the course is about how to mimic that behavior in our programs, and how to harness it to create complex behavior.  We'll start by learning a new concept: object-oriented programming.

\subsection{Object-Oriented Programming}
Let's look at an example of a program we should be familiar with.

\begin{verbatim}
int numCircles = 5;

void setup(){
  size(500,300);
  background(0);
  smooth();
  strokeWeight(1);
  frameRate(30);
  fill(150,50);
  Circles();
}

void draw(){
}

void mouseReleased(){
 Circles(); 
}

void Circles(){
  for(int i = 0; i < numCircles; i++){
   float x = random(width);
   float y = random(height);
   float radius = random(75) + 25;
   noStroke();
   ellipse(x,y,2*radius,2*radius);
   stroke(0,150);
   ellipse(x,y,radius/2,radius/2);
  }
}
\end{verbatim}

This program is pretty easy to follow, with perhaps the exception of \texttt{mouseReleased()}.  This function just run a command when you release a mouse button (after a click); we'll go into this sort of interactive command in more detail next time.  But for now, let's concentrate on the rest of the sketch.

Each time we click, some concentric circles appear in random position in the sketch -- the number is determined by \texttt{numCircles}, and our \texttt{for} loop draws all of the circles for us.  But these circles can't really do much -- if we clear the background, these circles are lost forever.  And even if we don't clear the background, once we throw these circles onto the screen they're pretty immobile.  Object-Oriented Programming solves this problem in a rather elegant way.

In object-oriented programming, we create \emph{classes} that defined \emph{objects}.  These classes serve as templates to tell us all of the properties of the object; we can then create as many copies (called \emph{instances}) of the object as we want using that template.  Here's an example circle class:

\begin{verbatim}
class Circle {
  float x,y,radius;
  color lineColor, fillColor;
  
  Circle() {
    x = random(width);
    y = random(height);
    radius = random(75) + 25;
    lineColor = color(random(255));
    fillColor = color(0,random(255),0);
  }
  
  void displayCircle() {
   noStroke();
   fill(fillColor);
   ellipse(x,y,2*radius,2*radius);
   stroke(lineColor,150);
   noFill();
   ellipse(x,y,radius/2,radius/2); 
  }  
}
\end{verbatim}

The class is divided into three components: object properties, the constructor, and the methods.  The first two lines are the \emph{object properties} -- they defined what properties every instance has.  Every instance has exactly these properties; no more, no less.  In this case, every circle has an x and y position, a radius, and a color for its stroke and fill.

The next chunk of code (starting with \texttt{Circle()}) is a function called the \emph{constructor}; this function defines how to create an object.  This function tells us that to create a circle, we give it zero arguments, and the parameter are all essentially chosen randomly.  You could define this function with arguments (like other functions we've written) to give each circle instance an assigned radius, for example.

The last part (\texttt{display()}) defines the \emph{methods} of the object -- every object has the ability to run these methods, that can modify itself or its environment.  This example method just draws the circle using the data we created with the constructor.  Let's look at an example of how to use a class.

\subsubsection{Example: Drawing Circles}
\begin{verbatim}
int numCircles = 5;

void setup(){
  size(500,300);
  background(0);
  smooth();
  strokeWeight(1);
  frameRate(30);
  fill(150,50);
  drawCircles();
}

void draw(){
}

void mouseReleased(){
 drawCircles(); 
}

void drawCircles(){
  for(int i = 0; i < numCircles; i++){
   Circle circleInstance = new Circle();
   circleInstance.displayCircle();
  }
}

class Circle {
  float x,y,radius;
  color lineColor, fillColor;
  
  Circle() {
    x = random(width);
    y = random(height);
    radius = random(75) + 25;
    lineColor = color(random(255));
    fillColor = color(0,random(255),0);
  }
  
  void displayCircle() {
   noStroke();
   fill(fillColor);
   ellipse(x,y,2*radius,2*radius);
   stroke(lineColor,150);
   noFill();
   ellipse(x,y,radius/2,radius/2); 
  }  
}
\end{verbatim}

This should look pretty similar to our initial example!  The biggest difference is in \texttt{drawCircles()}; instead of using a for look to manually draw the ellipses, we are now drawing them by creating a new instance of our circle class, and using its \texttt{display()} method to make the circle appear.  Note that when we create an instance of the circle, we use the \texttt{Circle} type, just like we used \texttt{int} or \texttt{float}.

Okay, so this seems like a lot of work just to be able to draw circles.  What else can we do with this? Now that we've created the circle object, each circle has a life of its own -- it has its own size, its own color, its own identity!  So now let's give each circle its own unique \emph{speed} -- and have them move around!

\subsubsection{Example: Moving Circles}
The circle object becomes:

\begin{verbatim}
class Circle {
  float x,y,radius,velocityX,velocityY;
  color lineColor, fillColor;
  
  Circle() {
    x = random(width);
    y = random(height);
    radius = random(75) + 25;
    lineColor = color(random(255));
    fillColor = color(0,random(255),0);
    velocityX = random(10) - 5;
    velocityY = random(10) - 5;
  }
  
  void display() {
   noStroke();
   fill(fillColor);
   ellipse(x,y,2*radius,2*radius);
   stroke(lineColor,150);
   noFill();
   ellipse(x,y,radius/2,radius/2); 
  }  
  
  void update() {
    x += velocityX;
    y += velocityY;
    if (x > (width + radius)){
      x = 0 - radius;
    }
    if (x < (0 - radius)){
      x = width + radius;
    }
    if (y > (height + radius)){
      y = 0 - radius;
    }
    if (y < (0 - radius)){
      y = height + radius;
    }
  }
\end{verbatim}

Now we've added randomly generated velocities to the object properties, and use these properties to move the circle.  The last cluster of \texttt{if} statements are just there to make the circles wrap around the screen rather than wander off.

The rest of the code becomes:

\begin{verbatim}
void setup(){
  size(500,300);
  background(0);
  smooth();
  strokeWeight(1);
  frameRate(30);
  fill(150,50);
  drawCircles();
}

void draw(){
  background(0);
  for(int i = 0;i < circleArray.length;i++){
    Circle circleInstance = circleArray[i];
    circleInstance.update();
    circleInstance.display();
  }
}

void mouseReleased(){
 drawCircles(); 
}

void drawCircles(){
  for(int i = 0; i < numCircles; i++){
   Circle circleInstance = new Circle();
   circleInstance.display();
   circleArray = (Circle[])append(circleArray,circleInstance);
  }
}
\end{verbatim}

The important concept that we've added here is one of an \emph{array}.  An array is a list of objects, all of the same type.  We could have a list of integers (\texttt{int[] intArray = {1,2,3};}), or a list of floats (\texttt{float[] floatArray = {1.0,1.2,1.5};}) just as easily as an array of Circles.  The array is created by the addition of the brackets at the end.  Each element in the array has an \emph{index} (starting at zero!) that labels it; \texttt{intArray[0]} retrieves 1 and \texttt{intArray[2]} retrieves 3, for example.  Each array has a length (given by using the \texttt{length} method) and we can \emph{append} items to the array as shown in the \texttt{drawCircles()} function above.

Arrays are useful for keeping track of a large number of objects -- we will use them regularly to keep track of our objects so that we can recall them, update them, and redraw them in every frame.

\subsection{Project: Particle Emitter}
Now it's your turn to use classes to make useful sketches!  We're going to make a \emph{particle emitter}, which is a very common type of sketch (just Google for the term and see for yourself!).  The particle emitter should emit particles from the center of your sketch; and they should move away from it in some predefined way (a spiral? a straight line? a noisy line?  you choose!).  An outline of the sketch is in \texttt{ParticleEmitter.pde}.  You'll have to write the entire class, and then implement it -- use \texttt{CirclesOOP2.pde} as a guide if you're feeling a bit lost.

%Add some more comments
%Write a good example particle emitter!
%Another good example of OOP
